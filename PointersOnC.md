# Pointers On C

## 第1章 快速上手

1. 一个完整的C程序由`空白和注释`、`预处理指令`、`声明（函数原型、变量）`、`函数定义`等组成。
2. 空白和注释使程序容易阅读、理解和修改。
3. 若干连续的空白、注释与一个空格等价。
4. 注释是第一个`/*`与第一个`*/`之间的部分，其中多余的`/*`会被忽略。
5. 嵌套注释往往会产生错误。
6. 使代码失效的有效做法是使用预处理指令`#if 0`和`#endif`。
7. 预处理指令在编译前执行代码的修改操作，`#include`指令将对象文件完整地复制进目标文件中，`#define`指令用于定义符号常量或宏函数。
8. 函数原型用于告诉编译器函数的特征，包括返回值类型、函数名、参数个数、参数类型。
9. 函数原型中的参数名并不是必须的，但合适的参数名有助于理解函数的作用。
10. 编译器会根据函数原型对函数调用进行检查。
11. 所有C程序从`main函数`开始执行，`main函数`的返回值为`int型`，其值返回给操作系统。
12. 所有传递给函数的参数都是按值传递的，传递指针给被调用函数后，被调用函数可以通过间接引用方式修改参数值。

## 第2章 基本概念

1. 基本环境（软硬件条件）和过程
   - `编译环境`是源代码被转换成可执行机器代码的环境。
   - `执行环境`是实际执行机器代码的环境。
   - `编译环境`和`执行环境`可以不同。
   - 编程过程：文本编辑、预处理、编译、链接、执行。
   - 预处理：预处理器执行文本的插入、替换、删除等工作。
   - 编译：将每个源文件转换成目标代码。
   - 链接：由连接器将各个目标代码文件和库文件链接，形成可执行文件。
2. 编译和链接
   - 可以同时编译和链接同一程序的一个或多个源文件，如`gcc main.c tree.c queue.c`
   - 可以同时编译一个或多个源文件，产生以`.o`结尾的目标文件，如`gcc -c main.c tree.c queue.c`
   - 可以链接同一个程序的多个目标文件，产生可执行程序，如`gcc main.o tree.o queue.o`
   - 可以编译源文件，并与目标文件进行链接，形成可执行文件，如`gcc main.c tree.o queue.o`
   - 词法分析：由词法分析器取得标识符（token）序列。
   - 语法分析：从标识符结果中分析识别出各类短语，并构造语法分析树。
   - 语义分析：确定各个标识符的动作与属性。
   - 链接：连接器编译好的目标文件，及必要的库文件，链接到一起，并添加启动代码，形成可执行文件。
   - 启动代码：启动代码负责处理程序执行前后的一系列日常事务，如收集命令行参数、调用`main()`函数、结束指针、释放内存等？
3. 程序的风格
   - 按照功能分类，使用空行分隔不同代码段。
   - 使用缩进突出代码层次。
   - 注释成块出现，使其在视觉上突出。
   - 函数小而精，最好不超过一屏幕。
   - 高内聚、低耦合。

## 第3章 数据

1. C语言的基本数据类型有整型、浮点型、指针、聚合类型。
2. 整型家族
   - 整型家族包括字符型、短整型、整型、长整型，分为有符号（默认）和无符号两类。
   - 字符型本质上是小整型数，字符常量一般以整型常量储存。
   - 整型的长度一般是CPU的字长。
   - 整型字面量的类型一般以最短但足以容纳整个值的类型进行储存。
   - 通过在字面量后加`u`、`U`、`l`、`L`，改变其存储类型。
   - 枚举类型通过`enum flag {name1, name2, ...}`定义。
   - 枚举类型和整型可以通用，但应避免混用。
3. 浮点类型
   - 浮点型一般包括float、double、long double三类。
   - 浮点型字面量必须以十进制形式书写，必须有一个小数点或者一个指数。
   - 浮点字面量缺省情况下为double型，可以通过在其后加`f`、`F`、`l`、`L`，改变其存储类型。
4. 指针
   - 指针变量就是一个其值为内存地址的变量，其属性包括其指向的内存地址和该地址的数据类型。
   - 因为内存分配机制的原因，除了空指针`NULL`之外，不存在指针常量。
   - 编译器将多次出现的相同的字符串常量存储在一个地方，字符串常量的值是其收个字符的内存地址，可以将其赋值给字符指针。
5. 声明和初始化
   - 可以在声明数据的时候同时初始化，但其效率并无提升，静态变量仅在内存载入时初始化一次。
   - `signed`修饰符一般缺省，一般只用来调整`char`类型的符号状态。
   - `int *ptr`可以这么理解：`*ptr`产生的结果是`int`类型，所以`ptr`是指向`int`类型的指针。
6. 通过`typedef`而不是`#define`来定义新的数据类型。
7. 使用`const`关键字可以用来声明常量（不能修改的变量），常量必须在声明的同时进行初始化，
8. `const`修饰指针时，谁离`const`近，谁的值不能改变，如`int const *ptr`和`int * const ptr`。
9. 符号常量作为数组大小时，推荐使用`#define`形式。
10. 作用域
    - 标识符的作用域就是程序中该标识符可以被使用的区域。
    - 代码块作用域：一对`{}`之间的所有语句为一个代码块，代码块中声明的变量从声明处到代码块结束为止有效（嵌套代码块内再次声明同名变量导致外层变量被屏蔽除外），非嵌套代码块之间的变量可能使用相同的内存地址。
    - 函数作用域：语句标签具有函数作用域，一个函数体内的语句标签需唯一，`goto`语句可以跳转到定义在其后的语句标签。
    - 原型作用域：用于防止函数原型的形式参数重名。
    - 文件作用域：所有代码块之外声明的标识符具有文件作用域，从其声明的位置到文件结尾都可以被访问。
11. 链接属性
    - 标识符的连接属性决定如何处理在不同文件中出现的相同标识符。
    - 全局变量、函数体一般具有外部链接属性，除非使用`static`进行修改。
    - 使用`extern`声明定义在其他文件中的变量，以访问该变量。
12. 存储类型
    - 存储类型分为普通内存、运行时堆栈、硬件寄存器。
    - 全局变量、函数体、静态局部变量在程序加载时载入内存中。
    - 局部变量、函数参数在运行时才被创建，代码块、函数结束时被销毁，存储在运行时堆栈中。
    - 使用`register`关键字可以提示编译器将局部变量（包括函数参数）存储在寄存器中。
    - 存储在内存中的变量仅初始化一次，未初始化的置0值。

## 第4章 语句

1. C语言的语句有：空语句、表达式语句、if语句、while语句、for语句、do语句、break语句、continue语句、switch语句、goto语句。
2. 空语句：仅有一个分号的语句，不执行任何任务。
3. 表达式语句：表达式后加一个`；`构成表达式语句。
   - 表达式有`值`和`副作用`两个方面，有时需要利用其值，有时需要利用其副作用。
4. if语句：
   - 使用语句块，方便阅读和后期维护。
   - 0为假，非0为真，整型、浮点型、指针型都可直接作为表达式。
   - else从属于最靠近它的不完整的if语句。
   - 使用比较表达式，方便后期理解和维护。
5. break语句：
   - 在循环中，用于终止当前层次循环。
   - 在switch中，用于跳转到case列表的末尾。
6. continue语句：
   - 在while循环和do循环中，用于跳过之后的步骤，开启下一轮判断；在for循环中，用于跳转到调整部分。
   - 在switch中，无作用，当switch位于循环里面时，continue直接作用于循环。
7. switch语句：
   - switch后的表达式必须为整型。
   - case标签必须是整型常量表达式。
   - case只作为进入点，如不遇到break语句、goto语句，则会顺序执行到最后一个case的结尾。
   - 建议在每个case语句之后加上break语句，方便后期维护。
   - 当不同的case执行相同操作时，可以把该组case放到一起，仅在最后一个case中书写需要操作的语句，并添加break语句。
   - default语句：如果表达式的值与所有case的值都不匹配，则从default语句进入；default语句可以放在任何case出现的位置。
8. goto语句：
   - 标签：`标识符`后加上`：`，形成标签，标签具有函数作用域。
   - 除非用来跳出多重嵌套循环，否则不要轻易使用goto语句。

## 第5章 操作符和表达式

## 第6章 指针

## 第7章 函数

## 第8章 数组

## 第9章 字符串、字符和字节

## 第10章 结构和联合

## 第11章 动态内存分配

## 第12章 使用结构和指针

## 第13章 高级指针话题

## 第14章 预处理器

## 第15章 输入/输出函数

## 第16章 标准函数库

## 第17章 经典抽象数据类型

## 第18章 运行时环境
